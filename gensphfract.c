/****************************************************************************
 *
 * gensphfract.c -- Generate input for omp-c-ray
 *
 * Copyright (C) 2018--2022 Moreno Marzolla <moreno.marzolla(at)unibo.it>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 ****************************************************************************/

/***
% HPC -- Generate input for omp-c-ray
% Moreno Marzolla <moreno.marzolla@unibo.it>
% Last modified 2021-10-25

This program generates a fractal image that can be used as input to
the [c-ray ray tracer](https://github.com/jtsiomb/c-ray) written by
John Tsiombikas. This program is a C translation of
[gen_fract.scm](https://github.com/jtsiomb/c-ray/blob/master/c-ray-f/gen_fract.scm)
provided with c-ray.

Compile with:

        gcc -std=c99 -Wall -Wpedantic gensphfract.c -o gensphfract

Run with:

        ./gensphfract > sphfract.small.in

For an image with much more spheres:

        ./gensphfract 7 > sphfract.big.in

You can also pipe the output to c-ray:

        ./gensphfract | ./omp-c-ray > out.pbm

***/

#include <stdio.h>
#include <stdlib.h>

enum {
    NONE = 0,
    DIR_PX, /* positive X */
    DIR_NX, /* negative X */
    DIR_PY,
    DIR_NY,
    DIR_PZ,
    DIR_NZ
};

/**
 * A sphere of radius sz and center (cx, cy, cz)
 */
void sphere( float sz, float cx, float cy, float cz )
{
    printf("s %f %f %f %f 0.25 0.25 0.25 50.0 0.65\n",
           cx, cy, cz, sz);
}

/**
 * Generate a fractal structure of spheres.
 * sz: radius of this sphere
 * iter: number of iterations (0=stop)
 * cx, cy, cz: center of this sphere
 * dir: direction along which we are coming
 */
void generate( float sz, int iter, float cx, float cy, float cz, int dir )
{
    const float SCALE = 0.4f;

    if (iter <= 0)
        return;

    sphere(sz, cx, cy, cz);

    const float ofs = sz + sz*SCALE;
    const float new_sz = SCALE*sz;

    if (dir != DIR_NX)
        generate(new_sz, iter-1, cx+ofs, cy, cz, DIR_PX);

    if (dir != DIR_PX)
        generate(new_sz, iter-1, cx-ofs, cy, cz, DIR_NX);

    if (dir != DIR_NY)
        generate(new_sz, iter-1, cx, cy+ofs, cz, DIR_PY);

    if (dir != DIR_PY)
        generate(new_sz, iter-1, cx, cy-ofs, cz, DIR_NY);

    if (dir != DIR_NZ)
        generate(new_sz, iter-1, cx, cy, cz+ofs, DIR_PZ);

    if (dir != DIR_PZ)
        generate(new_sz, iter-1, cx, cy, cz-ofs, DIR_NZ);
}

int main( int argc, char *argv[] )
{
    int niter = 5;
    const int MAX_ITER = 7; /* You really don't want more than these iterations */

    if (argc > 2) {
        fprintf(stderr, "Usage %s [niter]\n", argv[0]);
        return EXIT_FAILURE;
    }

    if (argc > 1) {
        niter = atoi(argv[1]);
    }

    if (niter > MAX_ITER) {
        niter = MAX_ITER;
        fprintf(stderr, "Warning: niter too large; set to %d\n", niter);
    }

    printf("# Input for omp-c-ray\n");
    printf("# Generated by %s %d\n", argv[0], niter);
    generate(1.0f, niter, 0.0f, 0.0f, 0.0f, NONE);
    printf("s 0 -10002.25 0  10000  0.2 0.35 0.5  80.0  0.4\n"); /* floor */
    printf("s 0  10100.00 0  10000  0.5 0.2 0.1  40.0  0.0\n"); /* ceiling */
    printf("l -50 68 -50\n"); /* add a light */
    printf("l 40 40 150\n"); /* another light */
    printf("c -9 8 -17 45  0 -1 0\n"); /* camera */

    return EXIT_SUCCESS;
}
