/****************************************************************************
 *
 * gen-sphfract.c - Generate input for omp-c-ray
 *
 * Copyright (C) 2018--2023 Moreno Marzolla
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 ****************************************************************************/

/***
% Generate input for omp-c-ray
% [Moreno Marzolla](https://www.unibo.it/sitoweb/moreno.marzolla)
% Last updated: 2023-11-03

This program generates a fractal image that can be used as input to
the [c-ray ray tracer](https://github.com/jtsiomb/c-ray) written by
John Tsiombikas. This program is a C translation of
[gen_fract.scm](https://github.com/jtsiomb/c-ray/blob/master/c-ray-f/gen_fract.scm)
provided with c-ray.

Compile with:

        gcc -std=c99 -Wall -Wpedantic gen-sphfract.c -o gen-sphfract

Run with:

        ./gen-sphfract > sphfract.small.in

For an image with much more spheres:

        ./gen-sphfract 7 > sphfract.big.in

You can also pipe the output to c-ray:

        ./gen-sphfract | ./omp-c-ray > out.pbm

***/

#include <stdio.h>
#include <stdlib.h>

enum {
    NONE = 0,
    DIR_PX, /* positive X */
    DIR_NX, /* negative X */
    DIR_PY,
    DIR_NY,
    DIR_PZ,
    DIR_NZ
};

/**
 * A sphere of radius sz and center (cx, cy, cz)
 */
void sphere( float sz, float cx, float cy, float cz )
{
    printf("s %f %f %f %f 0.25 0.25 0.25 50.0 0.65\n",
           cx, cy, cz, sz);
}

/**
 * Generate a fractal structure of spheres.
 * sz: radius of this sphere
 * iter: number of iterations (0=stop)
 * cx, cy, cz: center of this sphere
 * dir: direction along which we are coming
 */
void generate( float sz, int iter, float cx, float cy, float cz, int dir )
{
    const float SCALE = 0.4f;

    if (iter <= 0)
        return;

    sphere(sz, cx, cy, cz);

    const float ofs = sz + sz*SCALE;
    const float new_sz = SCALE*sz;

    if (dir != DIR_NX)
        generate(new_sz, iter-1, cx+ofs, cy, cz, DIR_PX);

    if (dir != DIR_PX)
        generate(new_sz, iter-1, cx-ofs, cy, cz, DIR_NX);

    if (dir != DIR_NY)
        generate(new_sz, iter-1, cx, cy+ofs, cz, DIR_PY);

    if (dir != DIR_PY)
        generate(new_sz, iter-1, cx, cy-ofs, cz, DIR_NY);

    if (dir != DIR_NZ)
        generate(new_sz, iter-1, cx, cy, cz+ofs, DIR_PZ);

    if (dir != DIR_PZ)
        generate(new_sz, iter-1, cx, cy, cz-ofs, DIR_NZ);
}

int main( int argc, char *argv[] )
{
    int niter = 5;
    const int MAX_ITER = 7; /* You really don't want more than these iterations */

    if (argc > 2) {
        fprintf(stderr, "Usage %s [niter]\n", argv[0]);
        return EXIT_FAILURE;
    }

    if (argc > 1) {
        niter = atoi(argv[1]);
    }

    if (niter > MAX_ITER) {
        niter = MAX_ITER;
        fprintf(stderr, "Warning: niter too large; set to %d\n", niter);
    }

    printf("# Input for omp-c-ray\n");
    printf("# Generated by %s %d\n", argv[0], niter);
    generate(1.0f, niter, 0.0f, 0.0f, 0.0f, NONE);
    printf("s 0 -10002.25 0  10000  0.2 0.35 0.5  80.0  0.4\n"); /* floor */
    printf("s 0  10100.00 0  10000  0.5 0.2 0.1  40.0  0.0\n"); /* ceiling */
    printf("l -50 68 -50\n"); /* add a light */
    printf("l 40 40 150\n"); /* another light */
    printf("c -9 8 -17 45  0 -1 0\n"); /* camera */

    return EXIT_SUCCESS;
}
